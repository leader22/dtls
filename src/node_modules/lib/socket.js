'use strict';

const { Duplex, pipeline } = require('readable-stream');
const unicast = require('unicast');
const isDtls = require('is-dtls');
const streamfilter = require('streamfilter');
const debug = require('debug')('dtls:socket');
const ClientSession = require('session/client');
const ProtocolReader = require('fsm/protocol');
const Sender = require('lib/sender');
const Decoder = require('filter/decoder');
const Defragmentation = require('filter/defragmentation');
const Reordering = require('filter/reordering');
const x509 = require('@fidm/x509');
const { duplex: isDuplexStream } = require('is-stream');

const _session = Symbol('_session');
const _queue = Symbol('_queue');
const _protocol = Symbol('_protocol');
const _socket = Symbol('_socket');

const DTLS_MAX_MTU = 1420; // 1500 - IP/UDP/DTLS headers
const DTLS_MIN_MTU = 100;

/**
 * DTLS socket.
 */
class Socket extends Duplex {
  /**
   * @class Socket
   * @param {Object} options
   */
  constructor(options = {}) {
    super({ objectMode: false, decodeStrings: false, allowHalfOpen: true });

    const { socket } = options;

    const session = new ClientSession();
    const protocol = new ProtocolReader(session);
    const writer = new Sender(session);
    const decoder = new Decoder(session);
    const defrag = new Defragmentation();
    const reorder = new Reordering(session);

    // Disable Extended Master Secret Extension, RFC7627
    if (options.extendedMasterSecret === false) {
      session.extendedMasterSecret = false;
    }

    // Set up server certificate verify callback.
    if (typeof options.checkServerIdentity === 'function') {
      session.serverCertificateVerifyCallback = options.checkServerIdentity;
    }

    if (Buffer.isBuffer(options.certificate)) {
      session.clientCertificate = x509.Certificate.fromPEM(options.certificate);

      if (options.certificatePrivateKey !== undefined) {
        session.clientCertificatePrivateKey = options.certificatePrivateKey;
      } else {
        throw new Error('Expected private key');
      }
    }

    // Entering PSK identities consisting of up to 128 printable Unicode characters.
    if (Buffer.isBuffer(options.pskIdentity)) {
      session.clientPSKIdentity = options.pskIdentity;
    } else if (typeof options.pskIdentity === 'string') {
      session.clientPSKIdentity = Buffer.from(options.pskIdentity);
    }

    // Entering PSKs up to 64 octets in length as ASCII strings.
    if (Buffer.isBuffer(options.pskSecret)) {
      session.clientPSKSecret = options.pskSecret;
    } else if (typeof options.pskSecret === 'string') {
      session.clientPSKSecret = Buffer.from(options.pskSecret, 'ascii');
    }

    const onerror = err => {
      if (err) {
        this.emit('error', err);
      }
    };
    const isdtls = streamfilter(chunkFilter);

    pipeline(writer, socket, onerror);
    pipeline(socket, isdtls, decoder, reorder, defrag, protocol, onerror);

    this[_session] = session;
    this[_queue] = [];
    this[_protocol] = protocol;
    this[_socket] = socket;

    session.on('data', packet => this.push(packet));

    session.once('handshake:finish', () => {
      process.nextTick(() => this.emit('connect'));

      this[_queue].forEach(data => session.sendMessage(data));
      this[_queue].length = 0;
    });

    session.once('certificate', cert =>
      process.nextTick(() => this.emit('certificate', cert))
    );

    session.on('error', code =>
      this.emit('error', new Error(`alert code ${code}`))
    );
  }

  /**
   * Opens DTLS connection.
   * @param {Function} [callback]
   */
  connect(callback) {
    if (typeof callback === 'function') {
      this.once('connect', callback);
    }

    process.nextTick(() => this[_protocol].start());
  }

  /**
   * Set MTU (Minimal Transfer Unit) for the socket.
   * @param {number} mtu
   */
  setMTU(mtu) {
    if (typeof mtu !== 'number') {
      throw new TypeError('Invalid type of argument `mtu`');
    }

    const isValid =
      Number.isInteger(mtu) && mtu <= DTLS_MAX_MTU && mtu >= DTLS_MIN_MTU;

    if (isValid) {
      this[_session].mtu = mtu;
    } else {
      throw new Error('Invalid MTU');
    }
  }

  /**
   * Get MTU (Minimal Transfer Unit) for the socket.
   * @returns {number}
   */
  getMTU() {
    return this[_session].mtu;
  }

  /**
   * Close the underlying socket and stop listening for data on it.
   */
  close() {
    this[_socket].close();
  }

  /**
   * @private
   */
  _read() {} // eslint-disable-line class-methods-use-this

  /**
   * @private
   * @param {Buffer} chunk
   * @param {string} encoding
   * @param {Function} callback
   */
  _write(chunk, encoding, callback) {
    if (this[_session].isHandshakeInProcess) {
      this[_queue].push(chunk);
      this.once('connect', () => callback());
    } else {
      this[_session].sendMessage(chunk);
      callback();
    }
  }

  /**
   * @private
   */
  _destroy() {
    this[_queue].length = 0;
    this[_session] = null;
  }
}

/**
 * Connect the socket to dtls server.
 * @param {Object} options
 * @param {Function} [callback]
 * @returns {Socket}
 */
function connect(options = {}, callback) {
  if (!isDuplexStream(options.socket)) {
    options.socket = unicast.createSocket(options);
  }

  const socket = new Socket(options);
  socket.connect(callback);

  return socket;
}

/**
 * Check if incoming message is dtls.
 * @param {Buffer} data
 * @param {string} enc
 * @param {Function} callback
 */
function chunkFilter(data, enc, callback) {
  const isCorrect = isDtls(data);
  debug('got message, is dtls = %s', isCorrect);
  callback(!isCorrect);
}

module.exports = {
  connect,
};
